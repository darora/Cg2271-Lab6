
\documentclass[runningheads,a4paper]{report}
\usepackage{listings}
\usepackage{color}
\lstset{breaklines=true}


% Title Page
\title{CG2271 RTOS Lab 6 --- Synchronization Mechanisms}
\author{Divyanshu Arora(U096857U), Omer Iqbal(MATRIC\_NO\_HERE)}


\begin{document}
\maketitle
\section*{Q1}
\subsection{Output}
\lstset{language=C, caption=Output of program from lab manual,
  label=Output, numbers=left, frame=shadowbox,
  rulesepcolor=\color{black}}
\begin{lstlisting}
PRINT: Current value of ctr is 0
PRINT: ctr is too small. Zzzz.. g'night!
ADD: New value of ctr is 1
ADD: New value of ctr is 2
ADD: New value of ctr is 3
ADD: New value of ctr is 4
ADD: New value of ctr is 5
ADD: New value of ctr is 6
ADD: New value of ctr is 7
ADD: New value of ctr is 8
ADD: New value of ctr is 9
ADD: New value of ctr is 10
ADD: Reached limit of 10! Waking up print thread
PRINT: ctr is now 10! Exiting thread.
\end{lstlisting}

\subsection{Description}

The program spawns two threads---\texttt{add} and \texttt{print}. It
uses a condition variable \texttt{ctr\_cond} alongwith the
accompanying mutex \texttt{ctr\_mutex} to ensure that the
\texttt{print} thread doesn't print and exit until the condition
$ctr>=MAX\_COUNT$ has been met.
This condition can only be met by execution of the other thread, which
increments the \texttt{ctr} variable if necessary, and signals
\texttt{ctr\_cond} to wake up one of the threads waiting on it when it
is done.

\section*{Q2}

From the \textit{POSIX Programmer's Manual} page on
\texttt{pthread\_cond\_wait}---
\begin{quotation}
[...]
These functions[\texttt{pthread\_cond\_wait} \& \texttt{pthread\_cond\_timedwait}] atomically release \texttt{mutex}
  and cause the calling thread to block on the condition variable
  \texttt{cond}; atomically here means ``atomically with respect to access by another thread to the mutex and  then  the  condition
       variable''.  That  is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to \texttt{pthread\_cond\_broadcast()} or \texttt{pthread\_cond\_signal()} in that thread shall behave as
       if it were issued after the about-to-block thread has blocked. [...]
\end{quotation}

Since the \texttt{ctr\_mutex} variable is released by the
\texttt{pthread\_cont\_wait} call, there is no possibility for
deadlock.

\section*{Q3}

The first thread to call \texttt{sem\_wait} doesn't have to block,
because the call to \texttt{sem\_init} is passed an initial value of
\texttt{1}. After the first thread decrements the value, it
will still be non-zero, and therefore not block.

\section*{Q4}

One thread is woken up each time the main thread calls
\texttt{sem\_post}.

\section*{Q5}

\begin{itemize}
  \item Mutex provides mutual exclusion to a resource, i.e. only one
    thread can access the resource at a time. A semaphore can provide
    access to a user-defined number of threads.
  \item A semaphore can be shared between processes, whereas a mutex
    can't.
\end{itemize}



\end{document}
